name: IPTV Hunter & Aggregator

on:
  schedule:
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      deep_scan:
        description: '–ì–ª—É–±–æ–∫–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ'
        required: false
        default: 'false'

env:
  PYTHON_VERSION: '3.11'
  MAX_REPOS: 150

jobs:
  hunt-and-build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pages: write
      id-token: write
      releases: write
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          
      - name: Install dependencies
        run: |
          pip install requests beautifulsoup4 lxml aiohttp aiofiles fake-useragent urllib3
          sudo apt-get update && sudo apt-get install -y ffmpeg

      - name: Create IPTV Hunter Script
        run: |
          cat > iptv_hunter.py << 'EOF'
          import asyncio
          import aiohttp
          import aiofiles
          import requests
          import re
          import json
          import os
          import hashlib
          from urllib.parse import urljoin, urlparse, quote
          from bs4 import BeautifulSoup
          from fake_useragent import UserAgent
          from datetime import datetime
          import time
          import random
          
          class IPTVHunter:
              def __init__(self):
                  self.ua = UserAgent(fallback='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
                  self.session = requests.Session()
                  self.session.headers.update({'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'})
                  self.found_playlists = set()
                  self.valid_channels = []
                  self.dead_channels = []
                  self.epg_sources = {}
                  self.stats = {'active': 0, 'dead': 0, 'countries': {}}
                  
              def get_headers(self):
                  return {
                      'User-Agent': self.ua.random,
                      'Accept-Language': 'en-US,en;q=0.9',
                      'Accept-Encoding': 'gzip, deflate, br',
                      'DNT': '1',
                      'Connection': 'keep-alive',
                      'Upgrade-Insecure-Requests': '1'
                  }
              
              def search_github_via_google(self):
                  print("[*] –°–∫–∞–Ω–∏—Ä—É–µ–º GitHub —á–µ—Ä–µ–∑ –ø–æ–∏—Å–∫–æ–≤—ã–µ –¥–≤–∏–∂–∫–∏...")
                  queries = [
                      'site:github.com filetype:m3u IPTV "EXTM3U"',
                      'site:github.com "raw.githubusercontent.com" "iptv" "m3u"',
                      'site:github.com IPTV playlist m3u8 lang:en',
                      'site:raw.githubusercontent.com extm3u iptv'
                  ]
                  
                  found_urls = []
                  
                  for query in queries[:2] if os.getenv('DEEP_SCAN') != 'true' else queries:
                      try:
                          ddg_url = f"https://html.duckduckgo.com/html/?q={quote(query)}"
                          resp = self.session.get(ddg_url, headers=self.get_headers(), timeout=30)
                          soup = BeautifulSoup(resp.text, 'lxml')
                          
                          for link in soup.select('.result__a'):
                              href = link.get('href', '')
                              if 'github.com' in href and 'm3u' in href.lower():
                                  raw_url = self.convert_to_raw(href)
                                  if raw_url:
                                      found_urls.append(raw_url)
                          
                          time.sleep(random.uniform(2, 4))
                      except Exception as e:
                          print(f"[!] –û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞: {e}")
                  
                  try:
                      bing_query = "site:github.com filetype:m3u IPTV"
                      bing_url = f"https://www.bing.com/search?q={quote(bing_query)}"
                      resp = self.session.get(bing_url, headers=self.get_headers(), timeout=30)
                      urls = re.findall(r'https?://[^\s"\']+\.m3u[8]?', resp.text)
                      found_urls.extend(urls)
                  except:
                      pass
                  
                  return list(set(found_urls))
              
              def convert_to_raw(self, github_url):
                  if 'raw.githubusercontent.com' in github_url:
                      return github_url
                  
                  patterns = [
                      r'github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.+\.m3u[8]?)',
                      r'github\.com/([^/]+)/([^/]+)/raw/([^/]+)/(.+\.m3u[8]?)'
                  ]
                  
                  for pattern in patterns:
                      match = re.match(pattern, github_url)
                      if match:
                          user, repo, branch, path = match.groups()
                          return f"https://raw.githubusercontent.com/{user}/{repo}/{branch}/{path}"
                  return None
              
              def scrape_github_search_directly(self):
                  print("[*] –ü—Ä—è–º–æ–π —Å–∫—Ä–∞–ø–∏–Ω–≥ GitHub...")
                  urls = []
                  search_terms = ['filename:iptv.m3u', 'filename:playlist.m3u', 'extension:m3u iptv']
                  
                  for term in search_terms:
                      try:
                          gh_url = f"https://github.com/search?q={quote(term)}&type=code"
                          resp = self.session.get(gh_url, headers=self.get_headers(), timeout=20)
                          files = re.findall(r'href="(/[^/]+/[^/]+/blob/[^"]+\.m3u[8]?)"', resp.text)
                          for f in files[:20]:
                              full_url = f"https://github.com{f}"
                              raw = self.convert_to_raw(full_url)
                              if raw:
                                  urls.append(raw)
                          time.sleep(3)
                      except Exception as e:
                          print(f"[!] GitHub scrape error: {e}")
                  return urls
              
              async def validate_stream(self, session, url, channel_info):
                  try:
                      timeout = aiohttp.ClientTimeout(total=10)
                      start_time = time.time()
                      async with session.get(url, timeout=timeout, headers={'User-Agent': self.ua.random}) as resp:
                          latency = time.time() - start_time
                          if resp.status == 200:
                              content_type = resp.headers.get('content-type', '').lower()
                              if any(x in content_type for x in ['mpegurl', 'mpeg-url', 'octet-stream', 'video', 'audio']):
                                  chunk = await resp.content.read(512)
                                  if b'<!DOCTYPE' not in chunk and b'<html' not in chunk:
                                      return {
                                          'url': url,
                                          'status': 'active',
                                          'latency': round(latency, 2),
                                          'info': channel_info,
                                          'content_type': content_type
                                      }
                  except Exception as e:
                      pass
                  return {'status': 'dead', 'url': url, 'info': channel_info}
              
              async def process_playlist(self, url):
                  print(f"[*] –û–±—Ä–∞–±–æ—Ç–∫–∞: {url[:80]}...")
                  try:
                      async with aiohttp.ClientSession() as session:
                          async with session.get(url, headers={'User-Agent': self.ua.random}, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                              if resp.status != 200:
                                  return
                              content = await resp.text()
                              if '#EXTM3U' not in content:
                                  return
                              
                              channels = self.parse_m3u(content, url)
                              print(f"    –ù–∞–π–¥–µ–Ω–æ –∫–∞–Ω–∞–ª–æ–≤: {len(channels)}")
                              
                              test_tasks = [self.validate_stream(session, ch['url'], ch) for ch in channels[:15]]
                              results = await asyncio.gather(*test_tasks)
                              
                              active = [r for r in results if r and r.get('status') == 'active']
                              dead = [r for r in results if r and r.get('status') == 'dead']
                              
                              if len(active) >= 3:
                                  print(f"    [+] –ñ–∏–≤–æ–π –ø–ª–µ–π–ª–∏—Å—Ç! –ê–∫—Ç–∏–≤–Ω—ã—Ö: {len(active)}, –ú–µ—Ä—Ç–≤—ã—Ö: {len(dead)}")
                                  for ch in channels:
                                      self.valid_channels.append(ch)
                              else:
                                  print(f"    [-] –ú–µ—Ä—Ç–≤—ã–π –ø–ª–µ–π–ª–∏—Å—Ç (–∞–∫—Ç–∏–≤–Ω—ã—Ö: {len(active)})")
                  except Exception as e:
                      print(f"    [!] –û—à–∏–±–∫–∞: {e}")
              
              def parse_m3u(self, content, base_url):
                  channels = []
                  lines = content.split('\n')
                  current = {}
                  
                  for line in lines:
                      line = line.strip()
                      if line.startswith('#EXTINF:'):
                          tvg_id = re.search(r'tvg-id="([^"]*)"', line)
                          tvg_name = re.search(r'tvg-name="([^"]*)"', line)
                          tvg_logo = re.search(r'tvg-logo="([^"]*)"', line)
                          tvg_country = re.search(r'tvg-country="([^"]*)"', line)
                          group_title = re.search(r'group-title="([^"]*)"', line)
                          name = line.split(',')[-1] if ',' in line else 'Unknown'
                          
                          current = {
                              'name': name.strip(),
                              'tvg_id': tvg_id.group(1) if tvg_id else '',
                              'tvg_name': tvg_name.group(1) if tvg_name else name.strip(),
                              'logo': tvg_logo.group(1) if tvg_logo else '',
                              'country': tvg_country.group(1) if tvg_country else self.detect_country(line, base_url),
                              'group': group_title.group(1) if group_title else 'General'
                          }
                      elif line.startswith('http') and current:
                          current['url'] = line
                          current['hash'] = hashlib.md5(line.encode()).hexdigest()[:8]
                          channels.append(current)
                          current = {}
                  return channels
              
              def detect_country(self, line, base_url):
                  line_lower = line.lower()
                  countries = {
                      'ru': ['—Ä–æ—Å—Å–∏—è', 'russia', 'ru ', 'russian', '.ru/', 'ru-', 'ru_'],
                      'ua': ['—É–∫—Ä–∞–∏–Ω–∞', 'ukraine', 'ua '],
                      'us': ['usa', 'united states', 'america', 'us-'],
                      'uk': ['uk', 'united kingdom', 'british', 'england'],
                      'de': ['germany', 'deutsch', 'german', '.de/'],
                      'fr': ['france', 'french', 'francais'],
                      'it': ['italy', 'italian', 'italia'],
                      'es': ['spain', 'spanish', 'espa√±a'],
                      'tr': ['turkey', 't√ºrk', 'turkish']
                  }
                  
                  for code, keywords in countries.items():
                      if any(k in line_lower for k in keywords):
                          return code.upper()
                  return 'INT'
              
              async def hunt_epg(self, session, country_code):
                  epg_urls = {
                      'RU': ['https://iptvx.one/epg/epg.xml.gz', 'https://epg.sharecenter.io/ru.xml'],
                      'UA': ['https://epg.sharecenter.io/ua.xml'],
                      'US': ['https://epgshare01.online/epgshare01/epg_ripper_US1.xml.gz'],
                      'UK': ['https://epgshare01.online/epgshare01/epg_ripper_UK1.xml.gz'],
                      'INT': ['https://epgshare01.online/epgshare01/epg_ripper_ALL.xml.gz']
                  }
                  urls = epg_urls.get(country_code, epg_urls['INT'])
                  
                  for url in urls:
                      try:
                          headers = {
                              'User-Agent': self.ua.random,
                              'Referer': 'https://www.google.com/',
                              'Accept': 'application/xml,application/gzip,*/*'
                          }
                          async with session.get(url, headers=headers, timeout=aiohttp.ClientTimeout(total=30), ssl=False) as resp:
                              if resp.status == 200:
                                  return {'url': url, 'status': 'available'}
                      except:
                          continue
                  return {'url': 'Not available', 'status': 'unavailable'}
              
              async def run(self):
                  print("=== IPTV Hunter Pro ===")
                  urls = self.search_github_via_google()
                  urls += self.scrape_github_search_directly()
                  urls = list(set(urls))[:int(os.getenv('MAX_REPOS', 150))]
                  
                  print(f"[*] –í—Å–µ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤: {len(urls)}")
                  
                  tasks = [self.process_playlist(url) for url in urls]
                  await asyncio.gather(*tasks, return_exceptions=True)
                  
                  seen = set()
                  unique = []
                  for ch in self.valid_channels:
                      if ch['url'] not in seen:
                          seen.add(ch['url'])
                          unique.append(ch)
                  self.valid_channels = unique
                  
                  by_country = {}
                  for ch in self.valid_channels:
                      country = ch.get('country', 'INT')
                      if country not in by_country:
                          by_country[country] = []
                      by_country[country].append(ch)
                  
                  os.makedirs('playlists', exist_ok=True)
                  release_files = []
                  
                  for country, channels in by_country.items():
                      filename = f'playlists/iptv_{country.lower()}.m3u'
                      async with aiofiles.open(filename, 'w', encoding='utf-8') as f:
                          await f.write('#EXTM3U\n')
                          for ch in channels:
                              await f.write(f'#EXTINF:-1 tvg-id="{ch["tvg_id"]}" tvg-name="{ch["tvg_name"]}" tvg-logo="{ch["logo"]}" tvg-country="{ch["country"]}" group-title="{ch["group"]}",{ch["name"]}\n')
                              await f.write(f'{ch["url"]}\n')
                      release_files.append(filename)
                  
                  async with aiohttp.ClientSession() as session:
                      epg_tasks = [self.hunt_epg(session, c) for c in by_country.keys()]
                      epg_results = await asyncio.gather(*epg_tasks)
                      self.epg_sources = dict(zip(by_country.keys(), epg_results))
                  
                  # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ–±–∞ —Å–∞–π—Ç–∞
                  self.generate_main_page(by_country)
                  self.generate_full_page(by_country, release_files)
                  
                  # –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è —Ä–µ–ª–∏–∑–∞
                  total_active = sum(len(v) for v in by_country.values())
                  self.stats = {
                      'total_channels': total_active,
                      'countries': {k: len(v) for k, v in by_country.items()},
                      'epg_available': sum(1 for v in self.epg_sources.values() if v['status'] == 'available'),
                      'timestamp': datetime.now().isoformat()
                  }
                  
                  with open('release_metadata.json', 'w') as f:
                      json.dump({
                          'files': release_files,
                          'stats': self.stats,
                          'epg': self.epg_sources
                      }, f, indent=2)
                  
                  print(f"\n[‚úì] –ì–æ—Ç–æ–≤–æ! –°—Ç—Ä–∞–Ω: {len(by_country)}, –ö–∞–Ω–∞–ª–æ–≤: {total_active}")
              
              def generate_main_page(self, by_country):
                  """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å –æ–∫–æ—à–∫–æ–º"""
                  total = sum(len(v) for v in by_country.values())
                  
                  html = f"""<!DOCTYPE html>
          <html lang="ru">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>üì∫ IPTV Aggregator</title>
              <style>
                  * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                  body {{ 
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                      min-height: 100vh; 
                      display: flex; 
                      flex-direction: column; 
                      align-items: center; 
                      justify-content: center; 
                      padding: 20px;
                      color: white;
                  }}
                  .container {{ 
                      background: rgba(255,255,255,0.95); 
                      padding: 30px; 
                      border-radius: 20px; 
                      box-shadow: 0 20px 60px rgba(0,0,0,0.3); 
                      max-width: 900px; 
                      width: 100%;
                      color: #333;
                  }}
                  h1 {{ text-align: center; color: #667eea; margin-bottom: 10px; }}
                  .subtitle {{ text-align: center; color: #666; margin-bottom: 30px; }}
                  .iframe-container {{ 
                      width: 100%; 
                      height: 400px; 
                      border: 3px solid #667eea; 
                      border-radius: 12px; 
                      overflow: hidden; 
                      margin-bottom: 20px;
                      background: #f5f5f5;
                  }}
                  iframe {{ width: 100%; height: 100%; border: none; }}
                  .link-section {{ 
                      text-align: center; 
                      padding: 20px; 
                      background: #f8f9fa; 
                      border-radius: 12px; 
                      margin-top: 20px;
                  }}
                  .full-link {{ 
                      display: inline-block; 
                      padding: 15px 30px; 
                      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                      color: white; 
                      text-decoration: none; 
                      border-radius: 25px; 
                      font-weight: bold; 
                      font-size: 1.1em;
                      transition: transform 0.3s, box-shadow 0.3s;
                  }}
                  .full-link:hover {{ 
                      transform: translateY(-2px); 
                      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4); 
                  }}
                  .stats-mini {{ 
                      display: flex; 
                      justify-content: space-around; 
                      margin: 20px 0; 
                      flex-wrap: wrap;
                  }}
                  .stat {{ text-align: center; padding: 10px; }}
                  .stat-number {{ font-size: 2em; font-weight: bold; color: #667eea; }}
                  .stat-label {{ color: #666; font-size: 0.9em; }}
                  .update-time {{ 
                      text-align: center; 
                      color: #999; 
                      font-size: 0.85em; 
                      margin-top: 15px;
                  }}
              </style>
          </head>
          <body>
              <div class="container">
                  <h1>üåç IPTV Aggregator</h1>
                  <p class="subtitle">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±—Ä–∞–Ω–Ω—ã–µ —Ä–∞–±–æ—á–∏–µ –ø–ª–µ–π–ª–∏—Å—Ç—ã</p>
                  
                  <div class="stats-mini">
                      <div class="stat">
                          <div class="stat-number">{total}</div>
                          <div class="stat-label">–ö–∞–Ω–∞–ª–æ–≤</div>
                      </div>
                      <div class="stat">
                          <div class="stat-number">{len(by_country)}</div>
                          <div class="stat-label">–°—Ç—Ä–∞–Ω</div>
                      </div>
                      <div class="stat">
                          <div class="stat-number">‚úì</div>
                          <div class="stat-label">–ü—Ä–æ–≤–µ—Ä–µ–Ω–æ</div>
                      </div>
                  </div>
                  
                  <div class="iframe-container">
                      <iframe src="full.html" title="IPTV Preview"></iframe>
                  </div>
                  
                  <div class="link-section">
                      <p style="margin-bottom: 15px; color: #555;">–î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –≤—Å–µ—Ö –∫–∞–Ω–∞–ª–æ–≤, —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –ø–ª–µ–π–ª–∏—Å—Ç–æ–≤ –∏ EPG:</p>
                      <a href="full.html" class="full-link">üîó –û—Ç–∫—Ä—ã—Ç—å –ø–æ–ª–Ω—É—é –≤–µ—Ä—Å–∏—é —Å–∞–π—Ç–∞</a>
                  </div>
                  
                  <div class="update-time">
                      ü§ñ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {datetime.now().strftime('%d.%m.%Y %H:%M UTC')} | GitHub Actions
                  </div>
              </div>
          </body>
          </html>"""
                  
                  with open('index.html', 'w', encoding='utf-8') as f:
                      f.write(html)
                  print("[‚úì] –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ —Å–æ–∑–¥–∞–Ω–∞: index.html")
              
              def generate_full_page(self, by_country, files):
                  """–ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å–∞–π—Ç–∞"""
                  total = sum(len(v) for v in by_country.values())
                  
                  html = f"""<!DOCTYPE html>
          <html lang="ru">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>–ü–æ–ª–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥ IPTV</title>
              <style>
                  * {{ margin: 0; padding: 0; box-sizing: border-box; }}
                  body {{ 
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
                      background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); 
                      color: white; 
                      min-height: 100vh;
                      padding: 20px;
                  }}
                  .container {{ max-width: 1200px; margin: 0 auto; }}
                  header {{ text-align: center; margin-bottom: 40px; padding: 20px; }}
                  h1 {{ font-size: 2.5em; margin-bottom: 10px; }}
                  .back-link {{ 
                      display: inline-block; 
                      margin-bottom: 20px; 
                      color: #64ffda; 
                      text-decoration: none; 
                      font-size: 1.1em;
                  }}
                  .grid {{ 
                      display: grid; 
                      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
                      gap: 20px; 
                      margin-bottom: 40px;
                  }}
                  .card {{ 
                      background: rgba(255,255,255,0.1); 
                      backdrop-filter: blur(10px); 
                      padding: 25px; 
                      border-radius: 15px; 
                      border: 1px solid rgba(255,255,255,0.2);
                      transition: transform 0.3s;
                  }}
                  .card:hover {{ transform: translateY(-5px); background: rgba(255,255,255,0.15); }}
                  .country-name {{ font-size: 1.5em; margin-bottom: 10px; display: flex; align-items: center; gap: 10px; }}
                  .channel-count {{ 
                      font-size: 2em; 
                      color: #64ffda; 
                      font-weight: bold; 
                      margin: 10px 0;
                  }}
                  .download-btn {{ 
                      display: inline-block; 
                      margin-top: 10px; 
                      padding: 10px 20px; 
                      background: #64ffda; 
                      color: #1e3c72; 
                      text-decoration: none; 
                      border-radius: 20px; 
                      font-weight: bold;
                      margin-right: 10px;
                      margin-bottom: 5px;
                  }}
                  .epg-status {{ 
                      display: inline-block; 
                      padding: 3px 10px; 
                      border-radius: 12px; 
                      font-size: 0.75em; 
                      margin-left: 10px;
                  }}
                  .epg-ok {{ background: #00b894; }}
                  .epg-bad {{ background: #e17055; }}
                  .info-section {{ 
                      background: rgba(0,0,0,0.3); 
                      padding: 30px; 
                      border-radius: 15px; 
                      margin-top: 40px;
                  }}
                  .info-section h2 {{ color: #64ffda; margin-bottom: 20px; }}
                  .info-section ul {{ margin-left: 20px; line-height: 2; }}
                  .info-section code {{ 
                      background: rgba(255,255,255,0.2); 
                      padding: 2px 6px; 
                      border-radius: 4px; 
                      font-family: monospace;
                  }}
                  .badge {{ 
                      display: inline-block; 
                      padding: 5px 12px; 
                      background: rgba(255,255,255,0.2); 
                      border-radius: 15px; 
                      font-size: 0.85em; 
                      margin: 5px;
                  }}
              </style>
          </head>
          <body>
              <div class="container">
                  <header>
                      <a href="index.html" class="back-link">‚Üê –ù–∞–∑–∞–¥ –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
                      <h1>üì∫ –ü–æ–ª–Ω—ã–π –∫–∞—Ç–∞–ª–æ–≥ IPTV</h1>
                      <p>–í—Å–µ–≥–æ –Ω–∞–π–¥–µ–Ω–æ {total} —Ä–∞–±–æ—á–∏—Ö –∫–∞–Ω–∞–ª–æ–≤ –∏–∑ {len(by_country)} —Å—Ç—Ä–∞–Ω</p>
                  </header>
                  
                  <div class="grid">"""
                  
                  flags = {{'RU': 'üá∑üá∫', 'US': 'üá∫üá∏', 'UK': 'üá¨üáß', 'DE': 'üá©üá™', 'FR': 'üá´üá∑', 'IT': 'üáÆüáπ', 'ES': 'üá™üá∏', 'UA': 'üá∫üá¶', 'TR': 'üáπüá∑', 'INT': 'üåç'}}
                  
                  for country, channels in sorted(by_country.items(), key=lambda x: -len(x[1])):
                      flag = flags.get(country, 'üì°')
                      epg_data = self.epg_sources.get(country, {{}})
                      epg_class = 'epg-ok' if epg_data.get('status') == 'available' else 'epg-bad'
                      epg_text = 'EPG ‚úì' if epg_data.get('status') == 'available' else 'EPG ‚úó'
                      
                      html += f"""
                      <div class="card">
                          <div class="country-name">
                              {flag} {country}
                              <span class="epg-status {epg_class}">{epg_text}</span>
                          </div>
                          <div class="channel-count">{len(channels)}</div>
                          <p>–∞–∫—Ç–∏–≤–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–≤</p>
                          <a href="playlists/iptv_{country.lower()}.m3u" class="download-btn" download>–°–∫–∞—á–∞—Ç—å M3U</a>
                          <span class="badge">{epg_data.get('url', 'EPG N/A')[:30]}...</span>
                      </div>"""
                  
                  html += f"""
                  </div>
                  
                  <div class="info-section">
                      <h2>üì± –ö–∞–∫ —Å–º–æ—Ç—Ä–µ—Ç—å</h2>
                      <ul>
                          <li><strong>VLC Media Player:</strong> –ú–µ–¥–∏–∞ ‚Üí –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª ‚Üí –í—ã–±–µ—Ä–∏—Ç–µ .m3u</li>
                          <li><strong>Kodi:</strong> –î–æ–ø–æ–ª–Ω–µ–Ω–∏—è ‚Üí PVR IPTV Simple Client ‚Üí –ó–∞–≥—Ä—É–∑–∏—Ç—å M3U</li>
                          <li><strong>OTT Player</strong> (Smart TV): –ó–∞–≥—Ä—É–∑–∏—Ç–µ –ø–ª–µ–π–ª–∏—Å—Ç –ø–æ URL</li>
                          <li><strong>Telegram:</strong> –û—Ç–ø—Ä–∞–≤—å—Ç–µ –±–æ—Ç—É @WebIPTVBot —Ñ–∞–π–ª –ø–ª–µ–π–ª–∏—Å—Ç–∞</li>
                          <li><strong>iPhone/iPad:</strong> –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ <code>IPTV</code> –∏–ª–∏ <code>VLVideo</code></li>
                          <li><strong>Android:</strong> <code>IPTV Pro</code>, <code>Perfect Player</code>, <code>Televizo</code></li>
                      </ul>
                      
                      <h2 style="margin-top: 30px;">‚öôÔ∏è –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</h2>
                      <ul>
                          <li>–ü–ª–µ–π–ª–∏—Å—Ç—ã –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤</li>
                          <li>–ö–∞–∂–¥—ã–π –∫–∞–Ω–∞–ª –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –Ω–∞ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º</li>
                          <li>EPG (—Ç–µ–ª–µ–ø—Ä–æ–≥—Ä–∞–º–º–∞) –ø–æ–¥–≥—Ä—É–∂–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏, –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞</li>
                          <li>–ò—Å—Ç–æ—á–Ω–∏–∫–∏: GitHub, –ø—É–±–ª–∏—á–Ω—ã–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏ IPTV</li>
                          <li>–î–∞—Ç–∞ —Å–±–æ—Ä–∫–∏: {datetime.now().strftime('%d.%m.%Y %H:%M UTC')}</li>
                      </ul>
                  </div>
              </div>
          </body>
          </html>"""
                  
                  with open('full.html', 'w', encoding='utf-8') as f:
                      f.write(html)
                  print("[‚úì] –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å–æ–∑–¥–∞–Ω–∞: full.html")

          if __name__ == '__main__':
              hunter = IPTVHunter()
              asyncio.run(hunter.run())
          EOF

      - name: Run IPTV Hunter
        env:
          DEEP_SCAN: ${{ github.event.inputs.deep_scan || 'false' }}
          MAX_REPOS: 100
        run: python iptv_hunter.py

      - name: Setup Pages
        uses: actions/configure-pages@v4
        
      - name: Upload to Pages
        uses: actions/upload-pages-artifact@v3
        with:
          path: '.'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

      - name: Create Detailed Release
        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # –ß–∏—Ç–∞–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
          STATS=$(cat release_metadata.json)
          TOTAL=$(echo $STATS | python3 -c "import sys,json; print(sum(json.load(sys.stdin)['stats']['countries'].values()))")
          COUNTRIES=$(echo $STATS | python3 -c "import sys,json; d=json.load(sys.stdin)['stats']['countries']; print(', '.join([f'{k}({v})' for k,v in d.items()]))")
          EPG_COUNT=$(echo $STATS | python3 -c "import sys,json; print(json.load(sys.stdin)['stats']['epg_available'])")
          DATE=$(date +'%d.%m.%Y')
          TIME=$(date +'%H:%M')
          
          # –§–æ—Ä–º–∏—Ä—É–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–ª–∏–∑–∞
          RELEASE_NOTES="## üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±–æ—Ä–∫–∏
          **–î–∞—Ç–∞:** ${DATE} ${TIME} UTC
          
          ### üì∫ –ö–∞–Ω–∞–ª—ã
          - **–í—Å–µ–≥–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö:** ${TOTAL}
          - **–ü–æ —Å—Ç—Ä–∞–Ω–∞–º:** ${COUNTRIES}
          - **EPG –¥–æ—Å—Ç—É–ø–Ω–æ –¥–ª—è:** ${EPG_COUNT} —Å—Ç—Ä–∞–Ω
          
          ### ‚úÖ –°—Ç–∞—Ç—É—Å
          - üü¢ –ê–∫—Ç–∏–≤–Ω–æ: –†–∞–±–æ—á–∏–µ –ø–æ—Ç–æ–∫–∏ –ø—Ä–æ–≤–µ—Ä–µ–Ω—ã
          - üîÑ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: –ö–∞–∂–¥—ã–µ 6 —á–∞—Å–æ–≤
          - üì° –ò—Å—Ç–æ—á–Ω–∏–∫–∏: GitHub Public Repos
          
          ### üì• –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
          1. **–°–∫–∞—á–∞–π—Ç–µ** M3U —Ñ–∞–π–ª –≤–∞—à–µ–π —Å—Ç—Ä–∞–Ω—ã –∏–∑ —Å–ø–∏—Å–∫–∞ –Ω–∏–∂–µ
          2. **VLC:** –ú–µ–¥–∏–∞ ‚Üí –û—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª ‚Üí –í—ã–±—Ä–∞—Ç—å M3U
          3. **Kodi:** PVR IPTV Simple Client ‚Üí –ó–∞–≥—Ä—É–∑–∏—Ç—å M3U
          4. **Smart TV:** –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ OTT Player –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏
          5. **EPG:** –¢–µ–ª–µ–ø—Ä–æ–≥—Ä–∞–º–º–∞ –ø–æ–¥–≥—Ä—É–∑–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–∞)
          
          ### üåê –û–Ω–ª–∞–π–Ω –ø—Ä–æ—Å–º–æ—Ç—Ä
          - –û—Å–Ω–æ–≤–Ω–æ–π —Å–∞–π—Ç: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/
          - –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è: https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/full.html
          
          ### ‚ö†Ô∏è –í–∞–∂–Ω–æ
          - –ö–∞–Ω–∞–ª—ã –ø—Ä–æ–≤–µ—Ä—è–ª–∏—Å—å –Ω–∞ –º–æ–º–µ–Ω—Ç —Å–±–æ—Ä–∫–∏
          - –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–æ—Ç–æ–∫–∏ –º–æ–≥—É—Ç —É—Å—Ç–∞—Ä–µ—Ç—å –º–µ–∂–¥—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏
          - –î–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–ª–µ–π–ª–∏—Å—Ç—ã —Å EPG
          
          ---
          *–°–±–æ—Ä–∫–∞ –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —á–µ—Ä–µ–∑ GitHub Actions*"
          
          # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π —Ä–µ–ª–∏–∑ –µ—Å–ª–∏ –µ—Å—Ç—å
          gh release delete latest -y || true
          
          # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
          gh release create latest \
            --title "üåç IPTV Update ${DATE}" \
            --notes "${RELEASE_NOTES}" \
            --latest
          
          # –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª—ã
          for file in playlists/*.m3u; do
            [ -f "$file" ] && gh release upload latest "$file" --clobber
          done
          
          # –°–æ–∑–¥–∞–µ–º –æ–±—â–∏–π –ø–ª–µ–π–ª–∏—Å—Ç
          cat playlists/*.m3u > playlists/iptv_all.m3u 2>/dev/null || true
          [ -f "playlists/iptv_all.m3u" ] && gh release upload latest "playlists/iptv_all.m3u" --clobber

      - name: Cleanup old runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          retain_days: 7
          keep_minimum_runs: 3
